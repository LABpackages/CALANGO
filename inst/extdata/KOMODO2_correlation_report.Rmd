---
title: "KOMODO2 - results report"
output: html_document
---

Heatmap

```{r Heatmaps, echo = T, warnings = F, message = F}
#Prepare data.frame to plot

#getting data frame linking genome IDs to groups and short names

y.name <- defs$y.name
groups <- defs$groups
short.name <- defs$short.name

#y.name
#groups
#short.name

names <- data.frame(y.name, groups, short.name)
colnames(names) <- c("genomeID", "group", "shortName")

#names

#getting relevant annotation IDs
ids <- as.vector(df_cutoff$name)

#ids

#getting annotation frequencies
tmp <- defs$y[as.vector(ids)]
norm <- tmp/defs$denominator
#norm <- tmp

#norm

#rm(tmp)

rownames(norm) <- names$shortName[match(rownames(norm), names$genomeID)]
colnames(norm) <- paste0(ids, " - ", defs$annotation.cor[ids])

#norm

tree <- defs$tree

#getting a good tree

#replacing genome IDs by short names
tree$tip.label<-names[[3]][match(tree$tip.label, names[[1]])]

#2char
tree$tip.label <- sapply(tree$tip.label, function(x) as.character(x))

#final tree must be a dendrogram
tree2 <- as.dendrogram(ape::as.phylo(tree))

#plot(tree2)

clade_order <- order.dendrogram(tree2)

max <- ncol(norm)

mat <- as.matrix(norm[,1:max])

ord.mat <- mat[tree$tip.label,]

#ord.mat

my_palette <- colorRampPalette(c("white","blue"))(n = 51)


jColors <-
   with(names,
        data.frame(LABEL = levels(group),
                   COLOR = I(RColorBrewer::brewer.pal(nlevels(group), name = 'Set1'))))

jColors

tmp <- list()
tmp$species <- rownames(ord.mat)
tmp$group <- names$group[match(tmp$species, names$shortName)]
tmp$COLOR <- jColors$COLOR[match(tmp$group, jColors$LABEL)]
species2color <- unique(as.data.frame(tmp)[,c("species","COLOR")])
#rm(tmp)

species2color

#tmp <- normalize.quantiles(as.matrix(ord.mat))
#colnames(tmp) <- colnames(ord.mat)
#rownames(tmp) <- rownames(ord.mat)

#ord.norm.mat <- tmp
#rm(tmp)

distance2 = dist(as.matrix(t(ord.mat)), method = "euclidean")
#cluster2 = hclust(distance2, method = "ward.D2")

cluster2_final = dendextend::set(as.dendrogram(hclust(distance2, method=c("average"))), "branches_lwd", 1)

#plot(cluster2_final)

tree_final <- dendextend::set(tree2, "branches_lwd", 1)

plot(tree_final)

#Plot

heatmaply::heatmaply(
                          heatmaply::normalize(ord.mat),
                          file="heatmap.html",
                          Rowv = tree_final,
                          Colv = hclust(distance2, method=c("average")),
                          col = my_palette,
                          row_dend_left = TRUE,
                          RowSideColors = species2color$COLOR,
                          plot_method = "plotly"
                        )

```

Heatmap of annotation terms

```{r catso, echo = F, warnings = F, message = F}

htmltools::includeHTML("heatmap.html")

```


Annotation terms: q-values, size and coefficient of variation

```{r Correlation Plots, echo = F, warnings = F, message = F}
#Prepare data.frame to plot
#Plot
p <- ggplot2::ggplot(data    = df_cutoff,
                     mapping = ggplot2::aes(x           = -log10(corrected_contrasts),
                                            y           = -log10(Spearman_qvalue),
                                            label       = name,
                                            description = description,
                                            cv          = 1 / cv)) +
  ggplot2::geom_point(ggplot2::aes(size = size, alpha = cv)) +
  ggplot2::theme_bw() + 
  ggplot2::ggtitle("Spearman") +
  ggplot2::labs(x = "-log10(Corrected contrasts)",
                y = '-log10(Spearman correlation q-value)')
pl1 <- plotly::ggplotly(p, 
                        tooltip = c('size','name','description','x','y'))

p <- ggplot2::ggplot(data    = df_cutoff,
                     mapping = ggplot2::aes(x           = -log10(corrected_contrasts),
                                            y           = -log10(Kendall_qvalue),
                                            label       = name,
                                            description = description,
                                            cv          = 1 / cv)) +
  ggplot2::geom_point(ggplot2::aes(size = size, alpha = cv)) +
  ggplot2::theme_bw() + 
  ggplot2::ggtitle("Kendall") + 
  ggplot2::labs(x = "-log10(Corrected contrasts)",
                y = '-log10(Kendall correlation q-value)')
pl2 <- plotly::ggplotly(p, 
                        tooltip = c('x','y','size','name','description'))

p <- ggplot2::ggplot(data = df_cutoff,
                     mapping = ggplot2::aes(x           = -log10(corrected_contrasts),
                                            y           = -log10(Pearson_qvalue),
                                            label       = name,
                                            description = description,
                                            cv          = 1 / cv)) +
  ggplot2::geom_point(ggplot2::aes(size = size, alpha = cv)) +
  ggplot2::theme_bw() + 
  ggplot2::ggtitle("Pearson") +
  ggplot2::labs(x = "-log10(Corrected contrasts)",
                y = '-log10(Pearson correlation q-value)')

pl3 <- plotly::ggplotly(p,
                        tooltip = c('size','name','description','x','y'))

htmltools::tagList(pl1, pl2, pl3)
```


```{r Multiplot, echo = F, warning = FALSE}

# multiple scatterplots, with confidence intervals, in a single html page

#creating plot titles and axes labels
f <- list(size = 18, color = "black") # family = "Verdana",

title_p1 <- list(text      = "Raw data",
                 font      = f,
                 xref      = "Phenotype",
                 yref      = "Annotation term frequency",
                 yanchor   = "bottom",
                 xanchor   = "center",
                 align     = "center",
                 x         = 0.5,
                 y         = 1,
                 showarrow = FALSE)

title_p2      <- title_p1
title_p2$text <- "Rank data"
title_p2$xref <- "Phenotype rank"
title_p2$yref <- "Annotation term frequency rank"

title_p3      <- title_p1
title_p3$text <- "Phylogeny-aware linear model data"
title_p3$xref <- "Contrasts of phenotypes"
title_p3$yref <- "Contrasts of annotation term frequencies"

# TODO: multicore-parallelize this for loop.
for (i in seq_along(df_cutoff$name)){#df_cutoff$name[1:length(df_cutoff[, 1])]) { # get filtered to plot a lot
  
  fname <- df_cutoff$name[i]
  
  #output dir
  file <- paste0(cpd, fname, ".html")
  
  # setting up data
  Xdf         <- defs$x
  names(Xdf)  <- "X_var"
  Xdf$feature <- defs$y[, fname] / defs$denominator
  ID          <- row.names(Xdf)
  
  p1 <- ggplot2::ggplot(data    = Xdf, 
                        mapping = ggplot2::aes(x     = X_var, 
                                               y     = feature,
                                               label = ID)) + 
    ggplot2::geom_point() +
    #    expand_limits(x = 0, y = 0) +
    ggplot2::geom_smooth(method = "lm", formula = y ~ x, se = TRUE) + 
    ggplot2::theme_bw() +
    ggplot2::labs(x = "Phenotype value", 
                  y = "Annotation frequency")
  
  Xdf           <- as.data.frame(rank(defs$x[, 1]))
  rownames(Xdf) <- rownames(defs$x)
  names(Xdf)    <- "X_var"
  Xdf$feature   <- rank(defs$y[, fname] / defs$denominator)
  
  p2 <- ggplot2::ggplot(data    = Xdf, 
                        mapping = ggplot2::aes(x     = X_var, 
                                               y     = feature,
                                               label = ID)) + 
    ggplot2::geom_point() +
    ggplot2::geom_smooth(method = "loess", formula = y ~ x, se = TRUE) + 
    ggplot2::theme_bw() +
    ggplot2::labs(x = "Phenotype rank", 
                  y = "Annotation frequency rank")
  
  # TODO: plots only consider "pic". If we implement "gls", maybe we'll need to 
  # change something here too.
  tmp_x        <- defs$x[, 1]
  names(tmp_x) <- rownames(defs$x)
  contrast_x   <- ape::pic(x = tmp_x, phy = defs$tree)
  
  tmp_y        <- defs$y[, fname] / defs$denominator
  names(tmp_y) <- rownames(defs$x)
  contrast_y   <- ape::pic(x = tmp_y, phy = defs$tree)
  
  Xdf   <- data.frame(contrast_x, contrast_y)
  model <- stats::lm(contrast_y ~ contrast_x + 0)
  
  p3 <- ggplot2::ggplot(data    = Xdf, 
                        mapping = ggplot2::aes(x     = contrast_x, 
                                               y     = contrast_y, 
                                               label = rownames(Xdf))) +
    ggplot2::geom_point() +
    ggplot2::geom_abline(slope     = model$coefficients[1], 
                         intercept = 0, 
                         color     = c("#3366FFFF"), 
                         size      = 1) +
    ggplot2::theme_bw() +
    ggplot2::labs(x = "contrasts for phenotype", 
                  y = "Contrasts for annotation frequency")
  #		ggplot2::geom_smooth(method = "lm", se = FALSE) +
  #    ggplot2::geom_line(data = fortify(model), aes(x = contrast_x, y = .fitted))
  #		ggtitle(paste0("phylogeny-aware linear model data for "), i),
  #    ggtitle("Representation of raw data             Representation of rank data                Representation of phylogenetic-aware linear model data")
  
  p4 <- plotly::subplot(p1, p2, p3, shareX = TRUE, shareY = FALSE)
  
  p1ly <- plotly::ggplotly(p4,
                           tooltip = c('label','X_var','Normalized feature'))
  
  htmlwidgets::saveWidget(p1ly, file = file,
                          libdir = 'lib',
                          selfcontained = FALSE)
}

```

Results table, some columns are not visible by default. 
```{r Table, echo = F}

# CHECK HERE - NAMES, INDICES, URL ETC.

dtable <- dplyr::mutate(df_cutoff, 
                        corr_plots = paste0('<a  target=_blank href=', 
                                            cpd, "/", name,'.html>', 
                                            name,'</a>' )) #build link to plots

dtable <- DT::datatable(dtable,
                        escape = FALSE, 
                        filter = 'bottom',
                        extensions = 'Buttons', 
                        options = list(dom = 'Bfrtip', 
                                       buttons = c('colvis','csv'),
                                       columnDefs = list(list(visible = FALSE,
                                                              targets = 4:(length(df_cutoff) - 2))))) # prepare table

dtable
```


<!--
#```{r Multiplot,echo=F,warning=FALSE}
#Xdf <- KOMODO2$x
##nice scatterplot, with confidence intervals
#names(Xdf) <- "X_var"
#dir.create(paste0(wd,"/correlation_Plots"));
#lis<-list();
#for ( i in  df_cutoff$name[1:length(df_cutoff[,1])] ) { # get filtered to plot a lot
#	file<-paste0(wd,'/correlation_Plots/',i,'.html');
#	Xdf$feature <- KOMODO2$y[,i]/KOMODO2$denominator
##	model1 <- lm(Xdf$feature ~ Xdf$X_var)
##	conf_interval <- predict(model1, newdata=data.frame(QUET=3), interval="confidence", level = 0.95)
##	temp_var <- predict(model1, interval="prediction")
##	new_Xdf <- cbind(Xdf, temp_var)
#	ID=row.names(Xdf)
#	p2 <- ggplot(Xdf, aes(x = X_var, y = feature,label=ID) ) + 
#		geom_point() +
#		geom_smooth(method = "lm", se = TRUE) + 
#		theme_bw() +
#		ggtitle(i)	
#	p2ly<-ggplotly(p2,tooltip=c('label','X_var','Normalized feature'));
#	htmlwidgets::saveWidget(p2ly,file=file,title=i,libdir='lib',selfcontained=F)

#}

#Xdf <- as.data.frame(rank(KOMODO2$x[,1]))
#rownames(Xdf) <- rownames(KOMODO2$x)
##nice scatterplot, confidence intervals
#names(Xdf) <- "X_var"
#dir.create(paste0(wd,"/correlation_Plots2"));
#lis<-list();
#for ( i in  df_cutoff$name[1:length(df_cutoff[,1])] ) { # get filtered to plot a lot
#	file<-paste0(wd,'/correlation_Plots2/',i,'.html');
#	Xdf$feature <- rank(KOMODO2$y[,i]/KOMODO2$denominator)
##	model1 <- lm(Xdf$feature ~ Xdf$X_var)
##	conf_interval <- predict(model1, newdata=data.frame(QUET=3), ##interval="confidence", level = 0.95)
##	temp_var <- predict(model1, interval="prediction")
##	new_Xdf <- cbind(Xdf, temp_var)
#	ID=row.names(Xdf)
#	p2 <- ggplot(Xdf, aes(x = X_var, y = feature,label=ID)) + geom_point()+
##		geom_line(aes(y=lwr), color = "red", linetype = "dashed")+
##		geom_line(aes(y=upr), color = "red", linetype = "dashed")+
#		geom_smooth(method = "lm", se = TRUE) +
#		theme_bw() +
#		ggtitle(i)	
#	p2ly<-ggplotly(p2,tooltip=c('label','X_var','Normalized feature'));
#	htmlwidgets::saveWidget(p2ly,file=file,title=i,libdir='lib',selfcontained=F)
#}

#```

-->
