---
title: "KOMODO2 - results report"
output: html_document
---

Annotation terms: q-values, size and coefficient of variation

```{r Correlation Plots, echo = F, warnings = F, message = F}
#Prepare data.frame to plot
#Plot
p <- ggplot2::ggplot(data    = df_cutoff,
                     mapping = ggplot2::aes(x           = -log10(corrected_contrasts),
                                            y           = -log10(Spearman_qvalue),
                                            label       = name,
                                            description = description,
                                            cv          = 1 / cv)) +
  ggplot2::geom_point(ggplot2::aes(size = size, alpha = cv)) +
  ggplot2::theme_bw() + 
  ggplot2::ggtitle("Spearman") +
  ggplot2::labs(x = "-log10(Corrected contrasts)",
                y = '-log10(Spearman correlation q-value)')
pl1 <- plotly::ggplotly(p, 
                        tooltip = c('size','name','description','x','y'))

p <- ggplot2::ggplot(data    = df_cutoff,
                     mapping = ggplot2::aes(x           = -log10(corrected_contrasts),
                                            y           = -log10(Kendall_qvalue),
                                            label       = name,
                                            description = description,
                                            cv          = 1 / cv)) +
  ggplot2::geom_point(ggplot2::aes(size = size, alpha = cv)) +
  ggplot2::theme_bw() + 
  ggplot2::ggtitle("Kendall") + 
  ggplot2::labs(x = "-log10(Corrected contrasts)",
                y = '-log10(Kendall correlation q-value)')
pl2 <- plotly::ggplotly(p, 
                        tooltip = c('x','y','size','name','description'))

p <- ggplot2::ggplot(data = df_cutoff,
                     mapping = ggplot2::aes(x           = -log10(corrected_contrasts),
                                            y           = -log10(Pearson_qvalue),
                                            label       = name,
                                            description = description,
                                            cv          = 1 / cv)) +
  ggplot2::geom_point(ggplot2::aes(size = size, alpha = cv)) +
  ggplot2::theme_bw() + 
  ggplot2::ggtitle("Pearson") +
  ggplot2::labs(x = "-log10(Corrected contrasts)",
                y = '-log10(Pearson correlation q-value)')

pl3 <- plotly::ggplotly(p,
                        tooltip = c('size','name','description','x','y'))

htmltools::tagList(pl1, pl2, pl3)
```


```{r Multiplot, echo = F, warning = FALSE}

# multiple scatterplots, with confidence intervals, in a single html page

#creating plot titles and axes labels
f <- list(size = 18, color = "black") # family = "Verdana",

title_p1 <- list(text      = "Raw data",
                 font      = f,
                 xref      = "Phenotype",
                 yref      = "Annotation term frequency",
                 yanchor   = "bottom",
                 xanchor   = "center",
                 align     = "center",
                 x         = 0.5,
                 y         = 1,
                 showarrow = FALSE)

title_p2      <- title_p1
title_p2$text <- "Rank data"
title_p2$xref <- "Phenotype rank"
title_p2$yref <- "Annotation term frequency rank"

title_p3      <- title_p1
title_p3$text <- "Phylogeny-aware linear model data"
title_p3$xref <- "Contrasts of phenotypes"
title_p3$yref <- "Contrasts of annotation term frequencies"

# TODO: multicore-parallelize this for loop.
for (i in seq_along(df_cutoff$name)){#df_cutoff$name[1:length(df_cutoff[, 1])]) { # get filtered to plot a lot
  
  fname <- df_cutoff$name[i]
  
  #output dir
  file <- paste0(cpd, fname, ".html")
  
  # setting up data
  Xdf         <- defs$x
  names(Xdf)  <- "X_var"
  Xdf$feature <- defs$y[, i] / defs$denominator
  ID          <- row.names(Xdf)
  
  p1 <- ggplot2::ggplot(data    = Xdf, 
                        mapping = ggplot2::aes(x     = X_var, 
                                               y     = feature,
                                               label = ID)) + 
    ggplot2::geom_point() +
    #    expand_limits(x = 0, y = 0) +
    ggplot2::geom_smooth(method = "lm", se = TRUE) + 
    ggplot2::theme_bw() +
    ggplot2::labs(x = "Phenotype value", 
                  y = "Annotation frequency")
  
  Xdf           <- as.data.frame(rank(defs$x[, 1]))
  rownames(Xdf) <- rownames(defs$x)
  names(Xdf)    <- "X_var"
  Xdf$feature   <- rank(defs$y[, i] / defs$denominator)
  
  p2 <- ggplot2::ggplot(data    = Xdf, 
                        mapping = ggplot2::aes(x     = X_var, 
                                               y     = feature,
                                               label = ID)) + 
    ggplot2::geom_point() +
    ggplot2::geom_smooth(method = "loess", se = TRUE) + 
    ggplot2::theme_bw() +
    ggplot2::labs(x = "Phenotype rank", 
                  y = "Annotation frequency rank")
  
  # TODO: plots only consider "pic". If we implement "gls", maybe we'll need to 
  # change something here too.
  tmp_x        <- defs$x[, 1]
  names(tmp_x) <- rownames(defs$x)
  contrast_x   <- ape::pic(x = tmp_x, phy = defs$tree)
  
  tmp_y        <- defs$y[, i] / defs$denominator
  names(tmp_y) <- rownames(defs$x)
  contrast_y   <- ape::pic(x = tmp_y, phy = defs$tree)
  
  Xdf   <- data.frame(contrast_x, contrast_y)
  model <- stats::lm(contrast_y ~ contrast_x + 0)
  
  p3 <- ggplot2::ggplot(data    = Xdf, 
                        mapping = ggplot2::aes(x     = contrast_x, 
                                               y     = contrast_y, 
                                               label = rownames(Xdf))) +
    ggplot2::geom_point() +
    ggplot2::geom_abline(slope     = model$coefficients[1], 
                         intercept = 0, 
                         color     = c("#3366FFFF"), 
                         size      = 1) +
    ggplot2::theme_bw() +
    ggplot2::labs(x = "contrasts for phenotype", 
                  y = "Contrasts for annotation frequency")
  #		ggplot2::geom_smooth(method = "lm", se = FALSE) +
  #    ggplot2::geom_line(data = fortify(model), aes(x = contrast_x, y = .fitted))
  #		ggtitle(paste0("phylogeny-aware linear model data for "), i),
  #    ggtitle("Representation of raw data             Representation of rank data                Representation of phylogenetic-aware linear model data")
  
  p4 <- plotly::subplot(p1, p2, p3, shareX = TRUE, shareY = FALSE)
  
  p1ly <- plotly::ggplotly(p4,
                           tooltip = c('label','X_var','Normalized feature'))
  
  htmlwidgets::saveWidget(p1ly, file = file,
                          libdir = 'lib',
                          selfcontained = FALSE)
}

```

Results table, some columns are not visible by default. 
```{r Table, echo = F}

# CHECK HERE - NAMES, INDICES, URL ETC.

dtable <- dplyr::mutate(df_cutoff, 
                        corr_plots = gsub("//", "/", 
                                          paste0('<a  target=_blank href=', 
                                                 cpd, "/", name,'.html>', 
                                                 name,'</a>'),
                                          fixed = TRUE)) #build link to plots

dtable <- DT::datatable(dtable,
                        escape = FALSE, 
                        filter = 'bottom',
                        extensions = 'Buttons', 
                        options = list(dom = 'Bfrtip', 
                                       buttons = c('colvis','csv'),
                                       columnDefs = list(list(visible = FALSE,
                                                              targets = 4:(length(df_cutoff) - 2))))) # prepare table

dtable
```


<!--
#```{r Multiplot,echo=F,warning=FALSE}
#Xdf <- KOMODO2$x
##nice scatterplot, with confidence intervals
#names(Xdf) <- "X_var"
#dir.create(paste0(wd,"/correlation_Plots"));
#lis<-list();
#for ( i in  df_cutoff$name[1:length(df_cutoff[,1])] ) { # get filtered to plot a lot
#	file<-paste0(wd,'/correlation_Plots/',i,'.html');
#	Xdf$feature <- KOMODO2$y[,i]/KOMODO2$denominator
##	model1 <- lm(Xdf$feature ~ Xdf$X_var)
##	conf_interval <- predict(model1, newdata=data.frame(QUET=3), interval="confidence", level = 0.95)
##	temp_var <- predict(model1, interval="prediction")
##	new_Xdf <- cbind(Xdf, temp_var)
#	ID=row.names(Xdf)
#	p2 <- ggplot(Xdf, aes(x = X_var, y = feature,label=ID) ) + 
#		geom_point() +
#		geom_smooth(method = "lm", se = TRUE) + 
#		theme_bw() +
#		ggtitle(i)	
#	p2ly<-ggplotly(p2,tooltip=c('label','X_var','Normalized feature'));
#	htmlwidgets::saveWidget(p2ly,file=file,title=i,libdir='lib',selfcontained=F)

#}

#Xdf <- as.data.frame(rank(KOMODO2$x[,1]))
#rownames(Xdf) <- rownames(KOMODO2$x)
##nice scatterplot, confidence intervals
#names(Xdf) <- "X_var"
#dir.create(paste0(wd,"/correlation_Plots2"));
#lis<-list();
#for ( i in  df_cutoff$name[1:length(df_cutoff[,1])] ) { # get filtered to plot a lot
#	file<-paste0(wd,'/correlation_Plots2/',i,'.html');
#	Xdf$feature <- rank(KOMODO2$y[,i]/KOMODO2$denominator)
##	model1 <- lm(Xdf$feature ~ Xdf$X_var)
##	conf_interval <- predict(model1, newdata=data.frame(QUET=3), ##interval="confidence", level = 0.95)
##	temp_var <- predict(model1, interval="prediction")
##	new_Xdf <- cbind(Xdf, temp_var)
#	ID=row.names(Xdf)
#	p2 <- ggplot(Xdf, aes(x = X_var, y = feature,label=ID)) + geom_point()+
##		geom_line(aes(y=lwr), color = "red", linetype = "dashed")+
##		geom_line(aes(y=upr), color = "red", linetype = "dashed")+
#		geom_smooth(method = "lm", se = TRUE) +
#		theme_bw() +
#		ggtitle(i)	
#	p2ly<-ggplotly(p2,tooltip=c('label','X_var','Normalized feature'));
#	htmlwidgets::saveWidget(p2ly,file=file,title=i,libdir='lib',selfcontained=F)
#}

#```

-->
