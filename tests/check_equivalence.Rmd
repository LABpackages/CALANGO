---
title: 'Equivalence checking: KOMODO2 implementation'
author: "Felipe Campelo"
date: "12/03/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(kableExtra))
```

## Intro
This script verifies that the implementation and refactoring of the KOMODO2 
code into a CRAN-compliant R package generates equivalent results to the original scripts downloaded from [https://github.com/franciscolobo/KOMODO2/](https://github.com/franciscolobo/KOMODO2/tree/3ebc2e9fce9619d19e486653918bea4c8683c47f) (link points to specific commit point).

*****

## Load data
```{r, cache=TRUE}
data1 <- readRDS("../results/test_defs.rds")    # created using package
data2 <- readRDS("../results/test_KOMODO2.rds") # created using original scripts
```

*****

## Preliminary checks: field names and classes
```{r}
allnames <- unique(c(names(data1), names(data2)))

df <- data.frame(Name = allnames, data1 = "", data2 = "",
                 stringsAsFactors = FALSE)

for (i in seq_along(allnames)){
  df$data1[i] <- df$Name[i] %in% names(data1)
  df$data2[i] <- df$Name[i] %in% names(data2)
}

```
\newpage
Which fields are different between the two lists?

```{r}
df[df$data1 != df$data2, "Name"]
```

"Fix" fields that changed name between implementations (since this has no consequence on final results). These changes were done to:

1. Get all input field names to use a common syntax (points as separators)
2. Correct a minor inconsistency in some calculated field names ('.cor' in non-correlation annotations)

```{r}
names(data2)[which(names(data2) == "annotation_files_dir")] <- "annotation.files.dir"
names(data2)[which(names(data2) == "tree_path")] <- "tree.path"
names(data2)[which(names(data2) == "tree_type")] <- "tree.type"
names(data2)[which(names(data2) == "linear_model_cutoff")] <- "linear.model.cutoff"
names(data2)[which(names(data2) == "contrasts.cor")] <- "annotation.contrasts"
names(data2)[which(names(data2) == "sum.cor")] <- "annotation.sum"
names(data2)[which(names(data2) == "cv.cor")] <- "annotation.cv"
names(data2)[which(names(data2) == "sd.cor")] <- "annotation.sd"
```

Remove from the verification fields that were added/removed but do not change the final result of the analysis:

```{r}
data1$MHT.method <- NULL
data2$cl <- NULL
data2$yElementCount <- NULL
```

Check that all naming inconsistencies were treated prior to equivalence testing.

```{r}
data1 <- data1[names(data2)]      # put fields in the same order
all(names(data1) == names(data2)) # check that everything is equal
```

*****
\newpage
Check if the data types are different:
```{r}
df <- data.frame(Name = names(data1),
                 stringsAsFactors = FALSE)

df$ClassInData1 <- sapply(data1, class)
df$ClassInData2 <- sapply(data2, class)

df$SameClass <- (df$ClassInData1 == df$ClassInData2)

kable(df[!df$SameClass, 1:3]) %>% kable_styling("hover", full_width = TRUE)
```

Fix the two class differences above (these were known, and have no consequence in final analysis):
```{r}
tmp <- names(data2$heterogeneity)
data2$heterogeneity <- as.numeric(data2$heterogeneity)
names(data2$heterogeneity) <- tmp

tmp <- names(data2$mode)
data2$mode <- as.numeric(data2$mode)
names(data2$mode) <- tmp

# Check that all is ready for the final equivalence testing now:
all(sapply(data2, class) == sapply(data1, class))
```

*****
\newpage
## Equivalence of values and all other field properties
```{r}
kable(which(!mapply(identical, data1, data2))) %>% 
  kable_styling("hover", full_width = TRUE)
```

We can ignore the following fields, since differences here do not affect the results (diferences in file/folder paths and number of cores used):

- annotation.files.dir
- output.dir
- dataset.info
- tree.path
- cores

Let's now verify the remaining differences manually:

### `ontology`
This one is ok, as the difference is: "GO" vs "go"

```{r}
data1$ontology
data2$ontology
```

### `x`
This one is ok, as the difference is: column name, not used in the analysis
```{r}
# check that all values are equal
all(data1$x == data2$x)
# add a placeholder column name
colnames(data1$x) <- colnames(data2$x) <- "tmp"
# test full equivalence
identical(data1$x, data2$x)
```

### `greaterthanzero`
This one is also ok. The differences in this case were due to:

1. the numbers are now normalized by the length of their respective "y" entry
2. the way `greaterthanzero` was calculated in the original script was wrong (see code below):

```
 # This is how it was calculated in the original script 
 tmp <- as.numeric(lapply(KOMODO2$y, greaterthanzero))
 tmp <- (mapply("-", length(KOMODO2$y.name), tmp)) # <--------- DOESN'T MAKE SENSE
 names(tmp) <- names(KOMODO2$y)
 KOMODO2$greaterthanzero <- tmp
```

To check the problem (and see that the current implementation is correct):
```{r}
# Check initial values
kable(cbind(a=data1$greaterthanzero[1:5], 
      b=data2$greaterthanzero[1:5])) %>% 
  kable_styling("hover", full_width = TRUE)

# check that all y entries have the same length
(ly <- unique(sapply(data1$y, length)))

# Undo the wrong line in the original code, and then normalise for comparability with new code
tmp <- (ly - data2$greaterthanzero) / ly

identical(tmp, data1$greaterthanzero)
```

### `heterogeneity`
This one is ok, as the difference is: the numbers are now normalized by the length of their respective "y" entry)

```{r}
# Check equivalence by normalising values from data2
identical(data1$heterogeneity, data2$heterogeneity / ly)
```

\newpage
### `mode`
This one is ok, as the difference is due to some entries having more than 1 modal value, with the different routines picking up different (but all correct) modes. This difference should not influence the final analysis.

```{r}
# Get indices of different values
idx <- which(data1$mode != data2$mode)

# Get all modes of the observations detected above
tmp <- lapply(data2$y[idx],
              function(v){
                tmp <- sort(table(v), decreasing = TRUE)
                tmp <- as.numeric(names(tmp[tmp == tmp[1]]))
              })

# Check that in all these cases we have more than one mode
min(sapply(tmp, length))

# Check that the mode detected in data1 is amongst the modes 
# from data2 (calculated above)
all(mapply(function(a,b){a %in% b},
           a = data1$mode[idx],
           b = tmp))
```

*****
This successfully concludes the testing of equivalence between the implementations.
